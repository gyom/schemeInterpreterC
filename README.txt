This is a barebone scheme interpreter that I wrote in C around early 2010.

The purpose of this project was to put in practice everything that I had learned from "Structure and Interpretation of Computer Programs" (by Abelson and Sussman, http://mitpress.mit.edu/sicp/ ).

This Scheme interpreter features automatic garbage collection ("mark and sweep" style) and supports continuations. Support for continuations is done by reifying the execution stack, which is now a tree instead of a stack.

This implementation features a parser that can read Scheme from a string and convert it into an AST that can be interpreted. Some components (including the parser itself) have been written straight into an AST in C to limit the complexity (e.g. "atomic_functions.c").

In chapter 4 of SICP the authors present an implemented of a Scheme interpreter written in Scheme. This obviously avoids many of the challenges that are present when implementing an interpreter in C. These challenges are addressed in chapter 5 of SICP when they implement their interpreter in assembler. The point of my coding project was to combine the lessons from those two chapters by using C.


Parts of my code could have been generated by an external program (i.e. simple Scheme code that generates lots of C code that interprets more elaborate Scheme programs). This is probably how I will do things next time I decide to jump into such a project.

The biggest Scheme feature missing from this project is the support for macros.

This project is not actually meant to be used for running anything beside tests that verify the correctness of the interpreter (making sure that it's a success and not a bug-ridden implementation). Anyone looking for a complete Scheme implementation should be using GambitC (http://dynamo.iro.umontreal.ca/~gambit/wiki/index.php/Main_Page).


To try out the code, you can do

make test_SchemeObject
./test_SchemeObject

or you can try the more verbose versions

make test_SchemeObject_debug_execute
./test_SchemeObject

make test_SchemeObject_debug_gc
./test_SchemeObject

make test_SchemeObject_debug_callcc
./test_SchemeObject

These run a few tests and exit. As mentioned earlier, this project is not in a state where it is usable for anything other than running tests that verify that the implementation works. The tests being in the file "SchemeObject_test.c".

Essentially, the interpreter is started by having a piece of C code such as :


char * str = "((lambda ()												"
"       (define map														"
"		    (lambda (f L)												"
"			    (if (empty? L)											"
"				    empty												"
"                   (cons (f (car L)) (map f (cdr L))))))				"
"																		"
"       (define h														"
"           (lambda ()													"
"               (define A												"
"                   (call/cc (lambda (throw)							"
"                       (define f										"
"                           (lambda (x)									"
"                               (if (eq? x 0)							"
"	                                (call/cc (lambda (continue)         "
"                                               (throw continue)))      "
"	                                (* 7 x))))							"
"                       (map f (list 1 0 2 3 0)))))						"
"               (if (continuation? A)									"
"   			    (A -1)												"
"					A)))												"
"		(h)																"
"))                                                                     ";

MemorySpace * ms;
SchemeObject * out = sn1t_automem_parse_evaluate(str, &ms);

printf("\n");
SchemeObject_print(out);
printf("\n");

ms->destroy(ms);


